<PROLOG> -> const ifj = @ import ( "ifj24.zig" ) ; <FUNC_DECL> <FUNC_DECL_NEXT>
<FUNC_DECL> -> pub fn <ID> ( <FUNC_PARAMS> ) <FUNC_TYPE> <BODY> 
<FUNC_DECL_NEXT> -> <FUNC_DECL> <FUNC_DECL_NEXT>
<FUNC_DECL_NEXT> -> ε
<FUNC_PARAMS> -> <PARAM> <PARAM_NEXT>
<FUNC_PARAMS> -> ε
<PARAM> -> <ID> : <TYPE>
<PARAM_NEXT> -> , <PARAM> <PARAM_NEXT>
<PARAM_NEXT> -> ε
<BODY> -> { <STATEMENT_NEXT> }
<STATEMENT_NEXT> -> <STATEMENT> <STATEMENT_NEXT>
<STATEMENT_NEXT> -> ε
<STATEMENT> -> <ID> <FUNC_VAR>
<STATEMENT> -> <FUNC_CALL_IFJ> ;
<STATEMENT> -> <VAR_DECL>
<STATEMENT> -> <IF_STATEMENT>
<STATEMENT> -> <WHILE_STATEMENT>
<STATEMENT> -> <RETURN_STATEMENT>
<FUNC_VAR> -> <VAR_DEF>
<FUNC_VAR> -> <FUNC_CALL> ;
<FUNC_CALL> -> ( <FUNC_CALL_PARAMS> )
<FUNC_CALL_IFJ> -> ifj . <ID> ( <FUNC_CALL_PARAMS> )
<FUNC_CALL_PARAMS> -> <CALL_PARAM> <CALL_PARAM_NEXT>
<FUNC_CALL_PARAMS> -> ε
<CALL_PARAM_NEXT> -> , <CALL_PARAM> <CALL_PARAM_NEXT>
<CALL_PARAM_NEXT> -> ε
<CALL_PARAM> -> <EXPR>
<VAR_DECL> -> const <ID> <VAR_TYPE> <VAR_DEF>
<VAR_DECL> -> var <ID> <VAR_TYPE> <VAR_DEF>
<VAR_TYPE> -> ε
<VAR_TYPE> -> : <GEN_TYPE>
<VAR_DEF> -> = <EXPR> ;
<IF_STATEMENT> ->if ( <EXPR> ) <NOT_NULLABLE> <BODY> <ELSE_STATEMENT>
<ELSE_STATEMENT> -> else <BODY> 
<WHILE_STATEMENT> -> while ( <EXPR> ) <NOT_NULLABLE> <BODY>
<NOT_NULLABLE> -> | <ID> |
<NOT_NULLABLE> -> ε
<RETURN_STATEMENT> -> return <RETURN_EXPR> ;
<RETURN_EXPR> -> ε
<RETURN_EXPR> -> <EXPR>
<FUNC_TYPE> -> void
<FUNC_TYPE> -> <GEN_TYPE>
<GEN_TYPE> -> <NULLABLE_PART> <TYPE>
<NULLABLE_PART> -> ?
<NULLABLE_PART> -> ε
<TYPE> -> i32
<TYPE> -> f64
<TYPE> -> []u8
<EXPR> -> <VAL>
<EXPR> -> (
<VAL> -> intval
<VAL> -> floatval
<VAL> -> <ID> <VAL_FUNC_CONTINUE>
<VAL> -> <FUNC_CALL_IFJ>
<VAL_FUNC_CONTINUE> -> <FUNC_CALL>
<VAL_FUNC_CONTINUE> -> ε
<VAL> -> stringval
<ID> -> id
